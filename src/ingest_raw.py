import pandas as pd
from pathlib import Path
from src.db import get_conn

SQL_PATH = Path("src/models/create_tables.sql")
DATA_DIR = Path("data")

def run_sql_file(conn, path: Path) -> None:
    """Execute DDL file that creates schemas/tables/indexes."""
    conn.execute(path.read_text(encoding="utf-8"))

def upsert_df(conn, df: pd.DataFrame, table: str, pk_cols: list[str]) -> None:
    """
    Insert rows; if PK exists, update.
    This makes ingestion safe to rerun (idempotent).
    """
    cols = list(df.columns)
    col_list = ",".join(cols)
    placeholders = ",".join([f"%({c})s" for c in cols])
    pk_list = ",".join(pk_cols)
    update_set = ",".join([f"{c}=excluded.{c}" for c in cols if c not in pk_cols])

    sql = f"""
    insert into {table} ({col_list})
    values ({placeholders})
    on conflict ({pk_list})
    do update set {update_set};
    """

    with conn.cursor() as cur:
        cur.executemany(sql, df.to_dict(orient="records"))

def build_curated(conn) -> None:
    """Build dimensions and fact table from raw layer."""
    conn.execute("""
      insert into wh.dim_customer (customer_id, signup_date, country)
      select customer_id, signup_date, country from raw.customers
      on conflict (customer_id) do update
      set signup_date=excluded.signup_date, country=excluded.country;
    """)
    conn.execute("""
      insert into wh.dim_merchant (merchant_id, category, risk_tier)
      select merchant_id, category, risk_tier from raw.merchants
      on conflict (merchant_id) do update
      set category=excluded.category, risk_tier=excluded.risk_tier;
    """)
    conn.execute("""
      insert into wh.fact_transaction (tx_id, customer_sk, merchant_sk, tx_time, amount, currency, status)
      select
        t.tx_id,
        dc.customer_sk,
        dm.merchant_sk,
        t.tx_time,
        t.amount,
        t.currency,
        t.status
      from raw.transactions t
      join wh.dim_customer dc on dc.customer_id = t.customer_id
      join wh.dim_merchant dm on dm.merchant_id = t.merchant_id
      on conflict (tx_id) do update set
        customer_sk=excluded.customer_sk,
        merchant_sk=excluded.merchant_sk,
        tx_time=excluded.tx_time,
        amount=excluded.amount,
        currency=excluded.currency,
        status=excluded.status;
    """)

def main() -> None:
    # Read CSVs generated by src.generate_data
    customers = pd.read_csv(DATA_DIR / "customers.csv")
    merchants = pd.read_csv(DATA_DIR / "merchants.csv")
    tx = pd.read_csv(DATA_DIR / "transactions.csv")

    # Convert UUID columns to string for consistent parameter binding
    customers["customer_id"] = customers["customer_id"].astype(str)
    merchants["merchant_id"] = merchants["merchant_id"].astype(str)
    for c in ["tx_id", "customer_id", "merchant_id"]:
        tx[c] = tx[c].astype(str)

    with get_conn() as conn:
        run_sql_file(conn, SQL_PATH)

        upsert_df(conn, customers, "raw.customers", ["customer_id"])
        upsert_df(conn, merchants, "raw.merchants", ["merchant_id"])
        upsert_df(conn, tx, "raw.transactions", ["tx_id"])

        build_curated(conn)
        conn.commit()

        raw_count = conn.execute("select count(*) from raw.transactions;").fetchone()[0]
        fact_count = conn.execute("select count(*) from wh.fact_transaction;").fetchone()[0]
        print(f"Loaded raw.transactions={raw_count}, wh.fact_transaction={fact_count}")

if __name__ == "__main__":
    main()
